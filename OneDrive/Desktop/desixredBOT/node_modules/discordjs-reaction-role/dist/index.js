"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
function buildReverseSearch(config) {
    return config.reduce((index, conf) => {
        if (!index[conf.messageId]) {
            index[conf.messageId] = {};
        }
        index[conf.messageId][conf.reaction] = conf.roleId;
        return index;
    }, {});
}
class ReactionRole {
    constructor(client, config) {
        this.client = client;
        this.reverseConfig = buildReverseSearch(config);
        this.addReaction = this.addReaction.bind(this);
        this.removeReaction = this.removeReaction.bind(this);
        client.on("messageReactionAdd", this.addReaction);
        client.on("messageReactionRemove", this.removeReaction);
    }
    extractRole(reaction) {
        const messageId = reaction.message.id;
        const reactionName = reaction.emoji.name;
        if (this.reverseConfig[messageId] &&
            this.reverseConfig[messageId][reactionName]) {
            const roleId = this.reverseConfig[messageId][reactionName];
            return reaction.message.guild.roles.fetch(roleId);
        }
    }
    addReaction(reaction, user) {
        return __awaiter(this, void 0, void 0, function* () {
            /* Early leave if the message is not sent to a guild. */
            if (!reaction.message.guild) {
                return;
            }
            /* Get the member that reacted originally. */
            const member = yield reaction.message.guild.members.fetch(user.id);
            if (!member) {
                return;
            }
            /* Try to add the member to the guild. */
            yield this.extractRole(reaction).then((role) => {
                if (role) {
                    return member.roles.add(role);
                }
            });
        });
    }
    removeReaction(reaction, user) {
        return __awaiter(this, void 0, void 0, function* () {
            /* Early leave if the message is not sent to a guild. */
            if (!reaction.message.guild) {
                return;
            }
            /* Get the member that reacted originally. */
            const member = yield reaction.message.guild.members.fetch(user.id);
            if (!member) {
                return;
            }
            /* Try to add the member to the guild. */
            yield this.extractRole(reaction).then((role) => {
                if (role) {
                    return member.roles.remove(role);
                }
            });
        });
    }
    teardown() {
        this.client.off("messageReactionAdd", this.addReaction);
        this.client.off("messageReactionRemove", this.removeReaction);
    }
}
exports.default = ReactionRole;
